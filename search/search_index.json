{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Venvi","text":"<p>Venvi (Euro Hackathons Aggregator and Suggestion Platform) is a modern web application designed to help enthusiasts find and organize their participation in hackathons across Europe.</p> <p>What started as a weekend trip suggestion tool has evolved into a comprehensive aggregator that tracks upcoming events, synchronization with external sources, and provides a polished interface for discovery.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Automated Aggregation: Synchronizes with the Euro Hackathons API to keep listings up-to-date.</li> <li>Dynamic Discovery: A high-performance, HTMX-powered interface for browsing events.</li> <li>Real-time Interaction: \"Sync &amp; Refresh\" capability to fetch the latest events on demand.</li> <li>Strict Quality Standards: 100% test coverage and strict type checking ensure a reliable experience.</li> </ul>"},{"location":"#technology-stack","title":"Technology Stack","text":"<p>Venvi is built with modern, efficient tools:</p> <ul> <li>Backend: FastAPI &amp; Python 3.12+</li> <li>Database: PostgreSQL with SQLModel (SQLAlchemy + Pydantic)</li> <li>Frontend: HTML, Vanilla CSS, and HTMX</li> <li>Environment: Nix for reproducible development</li> <li>Automation: GitHub Actions (CI/CD) and Git Hooks (Pre-push)</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with development, please refer to the Guidelines.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This page provides autogenerated documentation for the Venvi codebase.</p>"},{"location":"api_reference/#models","title":"Models","text":""},{"location":"api_reference/#venvi.models.hackathon.Hackathon","title":"<code>Hackathon</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents a hackathon event in the EU.</p> <p>This model stores core information about hackathons aggregated from various sources, including their location, dates, topics, and status.</p> Source code in <code>src/venvi/models/hackathon.py</code> <pre><code>class Hackathon(SQLModel, table=True):\n    \"\"\"\n    Represents a hackathon event in the EU.\n\n    This model stores core information about hackathons aggregated from various sources,\n    including their location, dates, topics, and status.\n    \"\"\"\n\n    id: UUID = Field(primary_key=True)\n    name: str\n    city: str\n    country_code: str\n    date_start: datetime = Field(sa_column=Column(DateTime(timezone=True)))\n    date_end: datetime = Field(sa_column=Column(DateTime(timezone=True)))\n    topics: list[str] = Field(sa_column=Column(JSON))\n    notes: str | None = None\n    url: str\n    status: str\n    is_new: bool = False\n    taken: bool = False\n</code></pre>"},{"location":"api_reference/#venvi.models.odh_event.ODHEvent","title":"<code>ODHEvent</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents an event from the South Tyrol Open Data Hub.</p> Source code in <code>src/venvi/models/odh_event.py</code> <pre><code>class ODHEvent(SQLModel, table=True):\n    \"\"\"\n    Represents an event from the South Tyrol Open Data Hub.\n    \"\"\"\n\n    id: str = Field(primary_key=True)\n    title: str\n    description: str | None = None\n    date_start: datetime = Field(sa_column=Column(DateTime(timezone=True)))\n    date_end: datetime = Field(sa_column=Column(DateTime(timezone=True)))\n    location: str | None = None\n    image_url: str | None = None\n    source_url: str | None = None\n    is_new: bool = True\n    taken: bool = False\n</code></pre>"},{"location":"api_reference/#services","title":"Services","text":"<p>Services for aggregating and synchronizing hackathon data from external providers.</p> <p>Services for fetching and synchronizing events from the South Tyrol Open Data Hub.</p>"},{"location":"api_reference/#venvi.services.ingestion.fetch_euro_hackathons","title":"<code>fetch_euro_hackathons()</code>  <code>async</code>","text":"<p>Fetches upcoming hackathons from the Euro Hackathons API.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict]: A list of raw hackathon data dictionaries.</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>src/venvi/services/ingestion.py</code> <pre><code>async def fetch_euro_hackathons() -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Fetches upcoming hackathons from the Euro Hackathons API.\n\n    Returns:\n        list[dict]: A list of raw hackathon data dictionaries.\n\n    Raises:\n        httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(EURO_HACKATHONS_API, params={\"status\": \"upcoming\"})\n        response.raise_for_status()\n        return response.json().get(\"data\", [])\n</code></pre>"},{"location":"api_reference/#venvi.services.ingestion.sync_hackathons","title":"<code>sync_hackathons(session)</code>  <code>async</code>","text":"<p>Synchronizes the local database with the Euro Hackathons API.</p> <p>New items are created, and existing items are updated if their data has changed.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of new hackathons added.</p> Source code in <code>src/venvi/services/ingestion.py</code> <pre><code>async def sync_hackathons(session: AsyncSession) -&gt; int:\n    \"\"\"\n    Synchronizes the local database with the Euro Hackathons API.\n\n    New items are created, and existing items are updated if their data has changed.\n\n    Args:\n        session: The asynchronous database session.\n\n    Returns:\n        int: The number of new hackathons added.\n    \"\"\"\n    raw_hackathons = await fetch_euro_hackathons()\n    count = 0\n\n    for raw in raw_hackathons:\n        # Check if already exists\n        statement = select(Hackathon).where(Hackathon.id == raw[\"id\"])\n        result = await session.execute(statement)\n        existing = result.scalar_one_or_none()\n\n        if existing:\n            # Update fields if necessary\n            updated_instance = Hackathon.model_validate(raw)\n            update_data = updated_instance.model_dump(exclude_unset=True)\n            for key, value in update_data.items():\n                if hasattr(existing, key):\n                    setattr(existing, key, value)\n            session.add(existing)\n        else:\n            # Create new\n            hackathon = Hackathon.model_validate(raw)\n            session.add(hackathon)\n            count += 1\n\n    await session.commit()\n    return count\n</code></pre>"},{"location":"api_reference/#venvi.services.odh.fetch_odh_events","title":"<code>fetch_odh_events(page_size=20)</code>  <code>async</code>","text":"<p>Fetches events from the Open Data Hub API.</p> <p>Parameters:</p> Name Type Description Default <code>page_size</code> <code>int</code> <p>Number of events to fetch.</p> <code>20</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of raw event data dictionaries.</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>src/venvi/services/odh.py</code> <pre><code>async def fetch_odh_events(page_size: int = 20) -&gt; list[dict]:\n    \"\"\"\n    Fetches events from the Open Data Hub API.\n\n    Args:\n        page_size: Number of events to fetch.\n\n    Returns:\n        list[dict]: A list of raw event data dictionaries.\n\n    Raises:\n        httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    params = {\n        \"pagenumber\": 1,\n        \"pagesize\": page_size,\n    }\n\n    # We might want to filter by date or other parameters in the future.\n    # The current goal is basic integration.\n\n    async with httpx.AsyncClient() as client:\n        response = await client.get(ODH_API_URL, params=params)\n        response.raise_for_status()\n        data = response.json()\n        return data.get(\"Items\", [])\n</code></pre>"},{"location":"api_reference/#venvi.services.odh.map_odh_event","title":"<code>map_odh_event(raw)</code>","text":"<p>Maps raw ODH event data to the ODHEvent model.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>dict</code> <p>Dictionary containing raw event data from ODH.</p> required <p>Returns:</p> Name Type Description <code>ODHEvent</code> <code>ODHEvent</code> <p>The mapped model instance.</p> Source code in <code>src/venvi/services/odh.py</code> <pre><code>def map_odh_event(raw: dict) -&gt; ODHEvent:\n    \"\"\"\n    Maps raw ODH event data to the ODHEvent model.\n\n    Args:\n        raw: Dictionary containing raw event data from ODH.\n\n    Returns:\n        ODHEvent: The mapped model instance.\n    \"\"\"\n    # Defensive programming for handling optional fields and language selection\n    # (prefer 'en', fallback to 'it'/'de')\n\n    def get_start_date(raw_event: dict) -&gt; datetime:\n        # Assuming EventDate is a list and we take the first one or the main DateBegin\n        # The structure is a bit complex, let's try to find the best date\n        # Check 'DateBegin' first\n        if raw_event.get(\"DateBegin\"):\n            return datetime.fromisoformat(raw_event[\"DateBegin\"])\n        return datetime.now()  # Fallback, should not happen for valid events\n\n    def get_end_date(raw_event: dict) -&gt; datetime:\n        if raw_event.get(\"DateEnd\"):\n            return datetime.fromisoformat(raw_event[\"DateEnd\"])\n        return get_start_date(raw_event)\n\n    def get_localized_string(obj: dict | None, key: str) -&gt; str | None:\n        if not obj:\n            return None\n\n        # Try to find the key in language dictionaries\n        for lang in [\"en\", \"it\", \"de\"]:\n            lang_data = obj.get(lang)\n            if isinstance(lang_data, dict):\n                val = lang_data.get(key)\n                if val:\n                    return val\n        return None\n\n    details = raw.get(\"Detail\", {})\n\n    title = get_localized_string(details, \"Title\") or \"Untitled Event\"\n    # Description is often in 'BaseText' or 'IntroText'\n    description = get_localized_string(details, \"BaseText\") or get_localized_string(\n        details, \"IntroText\"\n    )\n\n    # Location\n    location_info = raw.get(\"ContactInfos\", {})\n    # Just take city from contact info if available, or LocationInfo\n    # The structure saw earlier had 'ContactInfos' with 'en', 'it', etc.\n    contact_en = location_info.get(\"en\", {})\n    city = contact_en.get(\"City\") or \"Unknown Location\"\n\n    # Image\n    image_url = None\n    gallery = raw.get(\"ImageGallery\", [])\n    if gallery:\n        image_url = gallery[0].get(\"ImageUrl\")\n\n    # Try to resolve or generate an ID\n    raw_id = raw.get(\"Id\")\n\n    raw_id = raw.get(\"Id\")\n    if not raw_id:\n        # try to find it in mapping\n        mapping = raw.get(\"Mapping\", {})\n        for source in mapping.values():\n            if \"rid\" in source:\n                raw_id = source[\"rid\"]\n                break\n\n    if not raw_id:\n        # Last resort fallback\n        raw_id = str(hash(title + str(raw.get(\"DateBegin\"))))\n\n    return ODHEvent(\n        id=raw_id,\n        title=title,\n        description=description,\n        date_start=get_start_date(raw),\n        date_end=get_end_date(raw),\n        location=city,\n        image_url=image_url,\n        source_url=None,  # Detail link might be constructed\n        is_new=True,\n    )\n</code></pre>"},{"location":"api_reference/#venvi.services.odh.sync_odh_events","title":"<code>sync_odh_events(session)</code>  <code>async</code>","text":"<p>Synchronizes the local database with the Open Data Hub API.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of new events added.</p> Source code in <code>src/venvi/services/odh.py</code> <pre><code>async def sync_odh_events(session: AsyncSession) -&gt; int:\n    \"\"\"\n    Synchronizes the local database with the Open Data Hub API.\n\n    Args:\n        session: The asynchronous database session.\n\n    Returns:\n        int: The number of new events added.\n    \"\"\"\n    raw_events = await fetch_odh_events()\n    count = 0\n\n    for raw in raw_events:\n        event = map_odh_event(raw)\n\n        # Check if exists\n        statement = select(ODHEvent).where(ODHEvent.id == event.id)\n        result = await session.execute(statement)\n        existing = result.scalar_one_or_none()\n\n        if existing:\n            # Update fields\n            update_data = event.model_dump(exclude_unset=True)\n            for key, value in update_data.items():\n                if key != \"is_new\":  # Don't overwrite is_new flag\n                    setattr(existing, key, value)\n            session.add(existing)\n        else:\n            session.add(event)\n            count += 1\n\n    await session.commit()\n    return count\n</code></pre>"},{"location":"api_reference/#routers-api","title":"Routers (API)","text":"<p>API endpoints for managing and viewing hackathon data.</p> <p>API endpoints for managing and viewing events from multiple sources.</p>"},{"location":"api_reference/#venvi.api.routers.hackathons.read_hackathons","title":"<code>read_hackathons(status=None, taken=None, session=Depends(get_session))</code>  <code>async</code>","text":"<p>Retrieves a list of hackathons from the database.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str | None</code> <p>Optional filter by hackathon status (e.g., 'upcoming', 'past').</p> <code>None</code> <code>taken</code> <code>bool | None</code> <p>Optional filter by 'taken' status.</p> <code>None</code> <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> <code>Depends(get_session)</code> <p>Returns:</p> Type Description <p>list[Hackathon]: A list of hackathon objects.</p> Source code in <code>src/venvi/api/routers/hackathons.py</code> <pre><code>@router.get(\"/\", response_model=list[Hackathon])\nasync def read_hackathons(\n    status: str | None = None,\n    taken: bool | None = None,\n    session: AsyncSession = Depends(get_session),\n):\n    \"\"\"\n    Retrieves a list of hackathons from the database.\n\n    Args:\n        status: Optional filter by hackathon status (e.g., 'upcoming', 'past').\n        taken: Optional filter by 'taken' status.\n        session: The asynchronous database session.\n\n    Returns:\n        list[Hackathon]: A list of hackathon objects.\n    \"\"\"\n    query = select(Hackathon)\n    if status:\n        query = query.where(Hackathon.status == status)\n    if taken is not None:\n        query = query.where(Hackathon.taken == taken)\n\n    result = await session.execute(query)\n    return result.scalars().all()\n</code></pre>"},{"location":"api_reference/#venvi.api.routers.hackathons.sync_data","title":"<code>sync_data(session=Depends(get_session))</code>  <code>async</code>","text":"<p>Triggers an on-demand synchronization with external data sources.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> <code>Depends(get_session)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A status message and the count of new items added.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the synchronization process fails.</p> Source code in <code>src/venvi/api/routers/hackathons.py</code> <pre><code>@router.post(\"/sync\")\nasync def sync_data(session: AsyncSession = Depends(get_session)):\n    \"\"\"\n    Triggers an on-demand synchronization with external data sources.\n\n    Args:\n        session: The asynchronous database session.\n\n    Returns:\n        dict: A status message and the count of new items added.\n\n    Raises:\n        HTTPException: If the synchronization process fails.\n    \"\"\"\n    try:\n        count = await sync_hackathons(session)\n        return {\"message\": \"Sync complete\", \"new_items\": count}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e)) from e\n</code></pre>"},{"location":"api_reference/#venvi.api.routers.hackathons.toggle_hackathon_taken","title":"<code>toggle_hackathon_taken(hackathon_id, taken, session=Depends(get_session))</code>  <code>async</code>","text":"<p>Updates the 'taken' status of a hackathon.</p> <p>Parameters:</p> Name Type Description Default <code>hackathon_id</code> <code>str</code> <p>The UUID of the hackathon.</p> required <code>taken</code> <code>bool</code> <p>The new taken status.</p> required Source code in <code>src/venvi/api/routers/hackathons.py</code> <pre><code>@router.patch(\"/{hackathon_id}/taken\", response_model=Hackathon)\nasync def toggle_hackathon_taken(\n    hackathon_id: str, taken: bool, session: AsyncSession = Depends(get_session)\n):\n    \"\"\"\n    Updates the 'taken' status of a hackathon.\n\n    Args:\n        hackathon_id: The UUID of the hackathon.\n        taken: The new taken status.\n    \"\"\"\n    # Note: hackathon_id is a string in URL but UUID in model.\n    # SQLAlchemy/SQLModel should handle coercion if passed as string to get(),\n    # but let's be safe or rely on FastAPI validation if we typed it as UUID.\n    # The models/hackathon.py defines id as UUID.\n\n    # We need to import UUID if we want to cast, or let sqlmodel handle it.\n    # session.get usually works with string for UUID pk but let's just pass it.\n\n    hackathon = await session.get(Hackathon, hackathon_id)\n    if not hackathon:\n        raise HTTPException(status_code=404, detail=\"Hackathon not found\")\n\n    hackathon.taken = taken\n    session.add(hackathon)\n    await session.commit()\n    await session.refresh(hackathon)\n    return hackathon\n</code></pre>"},{"location":"api_reference/#venvi.api.routers.events.read_odh_events","title":"<code>read_odh_events(taken=None, session=Depends(get_session))</code>  <code>async</code>","text":"<p>Retrieves a list of South Tyrol Open Data Hub events from the database.</p> <p>Parameters:</p> Name Type Description Default <code>taken</code> <code>bool | None</code> <p>Optional filter by 'taken' status.</p> <code>None</code> <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> <code>Depends(get_session)</code> <p>Returns:</p> Type Description <p>list[ODHEvent]: A list of ODH event objects.</p> Source code in <code>src/venvi/api/routers/events.py</code> <pre><code>@router.get(\"/odh\", response_model=list[ODHEvent])\n@router.get(\"/odh\", response_model=list[ODHEvent])\nasync def read_odh_events(\n    taken: bool | None = None, session: AsyncSession = Depends(get_session)\n):\n    \"\"\"\n    Retrieves a list of South Tyrol Open Data Hub events from the database.\n\n    Args:\n        taken: Optional filter by 'taken' status.\n        session: The asynchronous database session.\n\n    Returns:\n        list[ODHEvent]: A list of ODH event objects.\n    \"\"\"\n    query = select(ODHEvent)\n    if taken is not None:\n        query = query.where(ODHEvent.taken == taken)\n\n    result = await session.execute(query)\n    return result.scalars().all()\n</code></pre>"},{"location":"api_reference/#venvi.api.routers.events.sync_odh_data","title":"<code>sync_odh_data(session=Depends(get_session))</code>  <code>async</code>","text":"<p>Triggers an on-demand synchronization with South Tyrol Open Data Hub.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> <code>Depends(get_session)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A status message and the count of new items added.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the synchronization process fails.</p> Source code in <code>src/venvi/api/routers/events.py</code> <pre><code>@router.post(\"/odh/sync\")\nasync def sync_odh_data(session: AsyncSession = Depends(get_session)):\n    \"\"\"\n    Triggers an on-demand synchronization with South Tyrol Open Data Hub.\n\n    Args:\n        session: The asynchronous database session.\n\n    Returns:\n        dict: A status message and the count of new items added.\n\n    Raises:\n        HTTPException: If the synchronization process fails.\n    \"\"\"\n    try:\n        count = await sync_odh_events(session)\n        return {\"message\": \"Sync complete\", \"new_items\": count}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e)) from e\n</code></pre>"},{"location":"api_reference/#venvi.api.routers.events.toggle_odh_event_taken","title":"<code>toggle_odh_event_taken(event_id, taken, session=Depends(get_session))</code>  <code>async</code>","text":"<p>Updates the 'taken' status of an ODH event.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>str</code> <p>The ID of the event.</p> required <code>taken</code> <code>bool</code> <p>The new taken status.</p> required <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> <code>Depends(get_session)</code> <p>Returns:</p> Name Type Description <code>ODHEvent</code> <p>The updated event.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the event is not found.</p> Source code in <code>src/venvi/api/routers/events.py</code> <pre><code>@router.patch(\"/odh/{event_id}/taken\", response_model=ODHEvent)\nasync def toggle_odh_event_taken(\n    event_id: str, taken: bool, session: AsyncSession = Depends(get_session)\n):\n    \"\"\"\n    Updates the 'taken' status of an ODH event.\n\n    Args:\n        event_id: The ID of the event.\n        taken: The new taken status.\n        session: The asynchronous database session.\n\n    Returns:\n        ODHEvent: The updated event.\n\n    Raises:\n        HTTPException: If the event is not found.\n    \"\"\"\n    event = await session.get(ODHEvent, event_id)\n    if not event:\n        raise HTTPException(status_code=404, detail=\"Event not found\")\n\n    event.taken = taken\n    session.add(event)\n    await session.commit()\n    await session.refresh(event)\n    return event\n</code></pre>"},{"location":"api_reference/#routers-web","title":"Routers (Web)","text":"<p>Web routes for rendering the application's HTML interface.</p>"},{"location":"api_reference/#venvi.web.router.get_hackathons_partial","title":"<code>get_hackathons_partial(request, session=Depends(get_session))</code>  <code>async</code>","text":"<p>Renders the hackathon list partial for dynamic HTMX updates.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The Starlette request object.</p> required <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> <code>Depends(get_session)</code> <p>Returns:</p> Name Type Description <code>TemplateResponse</code> <code>Response</code> <p>The rendered partials/hackathon_list.html template.</p> Source code in <code>src/venvi/web/router.py</code> <pre><code>@router.get(\"/partials/hackathons\", include_in_schema=False)\nasync def get_hackathons_partial(\n    request: Request, session: AsyncSession = Depends(get_session)\n) -&gt; Response:\n    \"\"\"\n    Renders the hackathon list partial for dynamic HTMX updates.\n\n    Args:\n        request: The Starlette request object.\n        session: The asynchronous database session.\n\n    Returns:\n        TemplateResponse: The rendered partials/hackathon_list.html template.\n    \"\"\"\n    query = select(Hackathon).order_by(Hackathon.date_start.asc())\n    result = await session.execute(query)\n    hackathons: Sequence[Hackathon] = result.scalars().all()\n\n    return templates.TemplateResponse(\n        request, \"partials/hackathon_list.html\", {\"hackathons\": hackathons}\n    )\n</code></pre>"},{"location":"api_reference/#venvi.web.router.index","title":"<code>index(request)</code>  <code>async</code>","text":"<p>Renders the main application homepage.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The Starlette request object.</p> required <p>Returns:</p> Name Type Description <code>TemplateResponse</code> <code>Response</code> <p>The rendered index.html template.</p> Source code in <code>src/venvi/web/router.py</code> <pre><code>@router.get(\"/\", include_in_schema=False)\nasync def index(request: Request) -&gt; Response:\n    \"\"\"\n    Renders the main application homepage.\n\n    Args:\n        request: The Starlette request object.\n\n    Returns:\n        TemplateResponse: The rendered index.html template.\n    \"\"\"\n    return templates.TemplateResponse(request, \"index.html\")\n</code></pre>"},{"location":"guidelines/","title":"Project Guidelines and Standards","text":""},{"location":"guidelines/#core-mentality","title":"Core Mentality","text":"<ol> <li> <p>\"If it's not typed, it doesn't exist.\"</p> <ul> <li>Strict static type checking is mandatory.</li> <li><code>Any</code> is forbidden unless absolutely necessary and documented.</li> <li>We use Mypy in strict mode.</li> </ul> </li> <li> <p>\"Documentation is code.\"</p> <ul> <li>Documentation must be updated alongside code.</li> <li>We use MkDocs with Material theme.</li> <li>API documentation is auto-generated via FastAPI.</li> </ul> </li> <li> <p>\"Green Build or Bust.\"</p> <ul> <li>The CI pipeline is the ultimate source of truth.</li> <li>If the build fails (linting, types, tests), the code cannot be merged.</li> </ul> </li> <li> <p>\"Keep it Simple.\"</p> <ul> <li>Avoid over-engineering.</li> <li>Use standard library and established patterns where possible.</li> </ul> </li> </ol>"},{"location":"guidelines/#technology-stack","title":"Technology Stack","text":"<ul> <li>Language: Python 3.12+</li> <li>Package Manager: Poetry</li> <li>Web Framework: FastAPI</li> <li>ORM: SQLModel (SQLAlchemy + Pydantic)</li> <li>Database: PostgreSQL</li> <li>Testing: Pytest + Pytest-Cov</li> <li>Linting/Formatting: Ruff</li> <li>Type Checking: Mypy</li> </ul>"},{"location":"guidelines/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Dependency Management:</p> <ul> <li>Add dependencies: <code>poetry add &lt;package&gt;</code></li> <li>Add dev dependencies: <code>poetry add -D &lt;package&gt;</code></li> </ul> </li> <li> <p>Code Style:</p> <ul> <li>Run formatters: <code>poetry run ruff format .</code></li> <li>Run linters: <code>poetry run ruff check . --fix</code></li> </ul> </li> <li> <p>Type Checking:</p> <ul> <li>Run Mypy: <code>poetry run mypy .</code></li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Run tests: <code>poetry run pytest</code></li> </ul> </li> </ol>"},{"location":"guidelines/#cicd-requirements","title":"CI/CD Requirements","text":"<p>All Pull Requests must pass: -   Ruff formatting and linting. -   Mypy strict type checking. -   Pytest suite passing with acceptable coverage.</p>"}]}