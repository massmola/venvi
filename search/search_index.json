{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Venvi","text":"<p>Venvi (Euro Hackathons Aggregator and Suggestion Platform) is a modern web application designed to help enthusiasts find and organize their participation in hackathons across Europe.</p> <p>What started as a weekend trip suggestion tool has evolved into a comprehensive aggregator that tracks upcoming events, synchronization with external sources, and provides a polished interface for discovery.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Automated Aggregation: Synchronizes with the Euro Hackathons API to keep listings up-to-date.</li> <li>Dynamic Discovery: A high-performance, HTMX-powered interface for browsing events.</li> <li>Real-time Interaction: \"Sync &amp; Refresh\" capability to fetch the latest events on demand.</li> <li>Strict Quality Standards: 100% test coverage and strict type checking ensure a reliable experience.</li> </ul>"},{"location":"#technology-stack","title":"Technology Stack","text":"<p>Venvi is built with modern, efficient tools:</p> <ul> <li>Backend: FastAPI &amp; Python 3.12+</li> <li>Database: PostgreSQL with SQLModel (SQLAlchemy + Pydantic)</li> <li>Frontend: HTML, Vanilla CSS, and HTMX</li> <li>Environment: Nix for reproducible development</li> <li>Automation: GitHub Actions (CI/CD) and Git Hooks (Pre-push)</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with development, please refer to the Guidelines.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This page provides autogenerated documentation for the Venvi codebase.</p>"},{"location":"api_reference/#models","title":"Models","text":""},{"location":"api_reference/#venvi.models.event.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>A unified model representing an event from any source.</p> Source code in <code>src/venvi/models/event.py</code> <pre><code>class Event(SQLModel, table=True):\n    \"\"\"\n    A unified model representing an event from any source.\n    \"\"\"\n\n    id: str = Field(primary_key=True)\n    title: str\n    description: str | None = None\n    date_start: datetime = Field(sa_column=Column(DateTime(timezone=True)))\n    date_end: datetime = Field(sa_column=Column(DateTime(timezone=True)))\n    location: str | None = None\n    url: str\n    image_url: str | None = None\n    source_name: str\n    source_id: str\n    topics: list[str] = Field(default=[], sa_column=Column(JSON))\n    category: str = \"general\"\n    is_new: bool = True\n</code></pre>"},{"location":"api_reference/#services","title":"Services","text":""},{"location":"api_reference/#venvi.services.ingestion.sync_all_events","title":"<code>sync_all_events(session)</code>  <code>async</code>","text":"<p>Synchronizes events from all registered providers.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, int]</code> <p>A mapping of provider source names to the count of new events added.</p> Source code in <code>src/venvi/services/ingestion.py</code> <pre><code>async def sync_all_events(session: AsyncSession) -&gt; dict[str, int]:\n    \"\"\"\n    Synchronizes events from all registered providers.\n\n    Args:\n        session: The asynchronous database session.\n\n    Returns:\n        dict: A mapping of provider source names to the count of new events added.\n    \"\"\"\n    results = {}\n    for provider in PROVIDERS:\n        count = await provider.sync_events(session)\n        results[provider.source_name] = count\n    return results\n</code></pre>"},{"location":"api_reference/#venvi.services.providers.base.BaseEventProvider","title":"<code>BaseEventProvider</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for event providers.</p> Source code in <code>src/venvi/services/providers/base.py</code> <pre><code>class BaseEventProvider(ABC):\n    \"\"\"\n    Abstract base class for event providers.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def source_name(self) -&gt; str:\n        \"\"\"The identifier for this source (e.g., 'euro_hackathons').\"\"\"\n        pass\n\n    @abstractmethod\n    async def fetch_events(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Fetch raw event data from the source.\"\"\"\n        pass\n\n    @abstractmethod\n    def map_event(self, raw: dict[str, Any]) -&gt; Event:\n        \"\"\"Map raw data to the unified Event model.\"\"\"\n        pass\n\n    async def sync_events(self, session: AsyncSession) -&gt; int:\n        \"\"\"Fetch, map, and synchronize events with the database.\"\"\"\n        from sqlmodel import select\n\n        raw_events = await self.fetch_events()\n        count = 0\n\n        for raw in raw_events:\n            event = self.map_event(raw)\n            # Ensure source info is set\n            event.source_name = self.source_name\n\n            # Check if exists\n            statement = select(Event).where(Event.id == event.id)\n            result = await session.execute(statement)\n            existing = result.scalar_one_or_none()\n\n            if existing:\n                # Update fields\n                update_data = event.model_dump(exclude_unset=True)\n                for key, value in update_data.items():\n                    if key != \"is_new\":  # Don't overwrite is_new flag\n                        setattr(existing, key, value)\n                session.add(existing)\n            else:\n                session.add(event)\n                count += 1\n\n        await session.commit()\n        return count\n</code></pre>"},{"location":"api_reference/#venvi.services.providers.base.BaseEventProvider.source_name","title":"<code>source_name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The identifier for this source (e.g., 'euro_hackathons').</p>"},{"location":"api_reference/#venvi.services.providers.base.BaseEventProvider.fetch_events","title":"<code>fetch_events()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Fetch raw event data from the source.</p> Source code in <code>src/venvi/services/providers/base.py</code> <pre><code>@abstractmethod\nasync def fetch_events(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Fetch raw event data from the source.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#venvi.services.providers.base.BaseEventProvider.map_event","title":"<code>map_event(raw)</code>  <code>abstractmethod</code>","text":"<p>Map raw data to the unified Event model.</p> Source code in <code>src/venvi/services/providers/base.py</code> <pre><code>@abstractmethod\ndef map_event(self, raw: dict[str, Any]) -&gt; Event:\n    \"\"\"Map raw data to the unified Event model.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#venvi.services.providers.base.BaseEventProvider.sync_events","title":"<code>sync_events(session)</code>  <code>async</code>","text":"<p>Fetch, map, and synchronize events with the database.</p> Source code in <code>src/venvi/services/providers/base.py</code> <pre><code>async def sync_events(self, session: AsyncSession) -&gt; int:\n    \"\"\"Fetch, map, and synchronize events with the database.\"\"\"\n    from sqlmodel import select\n\n    raw_events = await self.fetch_events()\n    count = 0\n\n    for raw in raw_events:\n        event = self.map_event(raw)\n        # Ensure source info is set\n        event.source_name = self.source_name\n\n        # Check if exists\n        statement = select(Event).where(Event.id == event.id)\n        result = await session.execute(statement)\n        existing = result.scalar_one_or_none()\n\n        if existing:\n            # Update fields\n            update_data = event.model_dump(exclude_unset=True)\n            for key, value in update_data.items():\n                if key != \"is_new\":  # Don't overwrite is_new flag\n                    setattr(existing, key, value)\n            session.add(existing)\n        else:\n            session.add(event)\n            count += 1\n\n    await session.commit()\n    return count\n</code></pre>"},{"location":"api_reference/#routers-api","title":"Routers (API)","text":""},{"location":"api_reference/#venvi.api.routers.events.read_events","title":"<code>read_events(category=None, source=None, session=Depends(get_session))</code>  <code>async</code>","text":"<p>Retrieves a list of events from the database.</p> Source code in <code>src/venvi/api/routers/events.py</code> <pre><code>@router.get(\"/\", response_model=list[Event])\nasync def read_events(\n    category: str | None = None,\n    source: str | None = None,\n    session: AsyncSession = Depends(get_session),\n):\n    \"\"\"\n    Retrieves a list of events from the database.\n    \"\"\"\n    query = select(Event).order_by(Event.date_start.asc())\n    if category:\n        query = query.where(Event.category == category)\n    if source:\n        query = query.where(Event.source_name == source)\n\n    result = await session.execute(query)\n    return result.scalars().all()\n</code></pre>"},{"location":"api_reference/#venvi.api.routers.events.sync_events","title":"<code>sync_events(session=Depends(get_session))</code>  <code>async</code>","text":"<p>Triggers an on-demand synchronization with all event providers.</p> Source code in <code>src/venvi/api/routers/events.py</code> <pre><code>@router.post(\"/sync\")\nasync def sync_events(session: AsyncSession = Depends(get_session)):\n    \"\"\"\n    Triggers an on-demand synchronization with all event providers.\n    \"\"\"\n    try:\n        results = await sync_all_events(session)\n        total_new = sum(results.values())\n        return {\"message\": \"Sync complete\", \"new_items\": results, \"total\": total_new}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e)) from e\n</code></pre>"},{"location":"api_reference/#routers-web","title":"Routers (Web)","text":"<p>Web routes for rendering the application's HTML interface.</p>"},{"location":"api_reference/#venvi.web.router.get_events_partial","title":"<code>get_events_partial(request, session=Depends(get_session))</code>  <code>async</code>","text":"<p>Renders the event list partial for dynamic HTMX updates.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The Starlette request object.</p> required <code>session</code> <code>AsyncSession</code> <p>The asynchronous database session.</p> <code>Depends(get_session)</code> <p>Returns:</p> Name Type Description <code>TemplateResponse</code> <code>Response</code> <p>The rendered partials/event_list.html template.</p> Source code in <code>src/venvi/web/router.py</code> <pre><code>@router.get(\"/partials/events\", include_in_schema=False)\nasync def get_events_partial(\n    request: Request, session: AsyncSession = Depends(get_session)\n) -&gt; Response:\n    \"\"\"\n    Renders the event list partial for dynamic HTMX updates.\n\n    Args:\n        request: The Starlette request object.\n        session: The asynchronous database session.\n\n    Returns:\n        TemplateResponse: The rendered partials/event_list.html template.\n    \"\"\"\n    query = select(Event).order_by(Event.date_start.asc())\n    result = await session.execute(query)\n    events: Sequence[Event] = result.scalars().all()\n\n    return templates.TemplateResponse(\n        request, \"partials/event_list.html\", {\"events\": events}\n    )\n</code></pre>"},{"location":"api_reference/#venvi.web.router.index","title":"<code>index(request)</code>  <code>async</code>","text":"<p>Renders the main application homepage.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The Starlette request object.</p> required <p>Returns:</p> Name Type Description <code>TemplateResponse</code> <code>Response</code> <p>The rendered index.html template.</p> Source code in <code>src/venvi/web/router.py</code> <pre><code>@router.get(\"/\", include_in_schema=False)\nasync def index(request: Request) -&gt; Response:\n    \"\"\"\n    Renders the main application homepage.\n\n    Args:\n        request: The Starlette request object.\n\n    Returns:\n        TemplateResponse: The rendered index.html template.\n    \"\"\"\n    return templates.TemplateResponse(request, \"index.html\")\n</code></pre>"},{"location":"guidelines/","title":"Project Guidelines and Standards","text":""},{"location":"guidelines/#core-mentality","title":"Core Mentality","text":"<ol> <li> <p>\"If it's not typed, it doesn't exist.\"</p> <ul> <li>Strict static type checking is mandatory.</li> <li><code>Any</code> is forbidden unless absolutely necessary and documented.</li> <li>We use Mypy in strict mode.</li> </ul> </li> <li> <p>\"Documentation is code.\"</p> <ul> <li>Documentation must be updated alongside code.</li> <li>We use MkDocs with Material theme.</li> <li>API documentation is auto-generated via FastAPI.</li> </ul> </li> <li> <p>\"Green Build or Bust.\"</p> <ul> <li>The CI pipeline is the ultimate source of truth.</li> <li>If the build fails (linting, types, tests), the code cannot be merged.</li> </ul> </li> <li> <p>\"Keep it Simple.\"</p> <ul> <li>Avoid over-engineering.</li> <li>Use standard library and established patterns where possible.</li> </ul> </li> </ol>"},{"location":"guidelines/#technology-stack","title":"Technology Stack","text":"<ul> <li>Language: Python 3.12+</li> <li>Package Manager: Poetry</li> <li>Web Framework: FastAPI</li> <li>ORM: SQLModel (SQLAlchemy + Pydantic)</li> <li>Database: PostgreSQL</li> <li>Testing: Pytest + Pytest-Cov</li> <li>Linting/Formatting: Ruff</li> <li>Type Checking: Mypy</li> </ul>"},{"location":"guidelines/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Dependency Management:</p> <ul> <li>Add dependencies: <code>poetry add &lt;package&gt;</code></li> <li>Add dev dependencies: <code>poetry add -D &lt;package&gt;</code></li> </ul> </li> <li> <p>Code Style:</p> <ul> <li>Run formatters: <code>poetry run ruff format .</code></li> <li>Run linters: <code>poetry run ruff check . --fix</code></li> </ul> </li> <li> <p>Type Checking:</p> <ul> <li>Run Mypy: <code>poetry run mypy .</code></li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Run tests: <code>poetry run pytest</code></li> </ul> </li> </ol>"},{"location":"guidelines/#cicd-requirements","title":"CI/CD Requirements","text":"<p>All Pull Requests must pass: -   Ruff formatting and linting. -   Mypy strict type checking. -   Pytest suite passing with acceptable coverage.</p>"}]}